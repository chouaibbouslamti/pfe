// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

model User {
  id           BigInt        @id @default(autoincrement())
  email        String        @unique
  password     String
  firstName    String?       @map("first_name")
  lastName     String?       @map("last_name")
  username     String        @unique @db.VarChar(50)
  phoneNumber  String?       @map("phone_number")
  role         UserRole
  teamId       BigInt?       @map("team_id")
  isActive     Boolean?      @map("is_active") @db.Bit(1)
  isApproved   Boolean       @map("is_approved") @db.Bit(1)
  createdAt    DateTime?     @default(now()) @map("created_at") @db.DateTime(6)
  lastLogin    DateTime?     @map("last_login") @db.DateTime(6)
  photoURL     String?       @map("photo_url") @db.VarChar(2048)
  team         Team?         @relation(fields: [teamId], references: [id])
  managedTeams Team[]        @relation("TeamManager")
  TeamMember   TeamMember[]  @relation("TeamMembers")

  @@map("users")
}

model Team {
  id          BigInt        @id @default(autoincrement())
  name        String        @db.VarChar(100)
  managerId   BigInt?       @map("manager_id") // This should match the relation name if it exists
  contact     String?
  createdAt   DateTime      @default(now()) @map("created_at") @db.DateTime(6)
  manager     User?         @relation("TeamManager", fields: [managerId], references: [id])
  users       User[] // Users directly in this team (if team_id is on User)
  TeamMember  TeamMember[]  @relation("TeamToMember")
  batches     Batch[]
  interventions Intervention[]
  AlertTeam AlertTeam[]

  @@map("teams")
}

// Explicit many-to-many relation table for Team and User (members)
model TeamMember {
  teamId  BigInt   @map("team_id")
  userId  BigInt   @map("user_id")
  team    Team     @relation("TeamToMember", fields: [teamId], references: [id])
  user    User     @relation("TeamMembers", fields: [userId], references: [id])
  assignedAt DateTime @default(now())
  assignedBy String? // Optional: UID or username of who assigned

  @@id([teamId, userId])
  @@map("team_members")
}


model Hangar {
  id        BigInt   @id @default(autoincrement())
  name      String   @db.VarChar(100)
  location  String   @db.VarChar(200)
  capacity  Float
  status    String // Consider ENUM('ACTIVE', 'INACTIVE') if your DB supports it and Prisma is configured for it
  createdAt DateTime @default(now()) @map("created_at") @db.DateTime(6)
  batches   Batch[]
  interventions Intervention[]
  kpis      Kpi[]
  alerts    Alert[] // Added missing opposite relation for Alert.hangar

  @@map("hangars")
}

model Batch {
  id            BigInt        @id @default(autoincrement())
  fertilizerType String       @map("fertilizer_type")
  quantity      Float        // Added from TypeScript types
  unit          String       @default("tonnes") @db.VarChar(50) // Added from TypeScript types
  stockedDate   DateTime      @map("stocked_date") @db.Date
  expectedTransportDate DateTime? @map("expected_transport_date") @db.Date
  maxStorageDays Int          @map("max_storage_days")
  hangarId      BigInt        @map("hangar_id")
  teamId        BigInt?       @map("team_id")
  status        BatchStatus   @default(STOCKED) // Added from TypeScript types
  createdAt     DateTime      @default(now()) @map("created_at") @db.DateTime(6)

  hangar        Hangar        @relation(fields: [hangarId], references: [id])
  team          Team?         @relation(fields: [teamId], references: [id])
  alerts        Alert[]
  interventions Intervention[]

  @@map("batches")
}

model Alert {
  id            BigInt    @id @default(autoincrement())
  title         String
  message       String    @db.VarChar(1000) // Increased length
  type          AlertType
  severity      AlertSeverity
  status        AlertStatus
  batchId       BigInt?   @map("batch_id") // Made optional to match SQL, check if this is intended. Your SQL Alert.batch_id is NOT NULL
  hangarId      BigInt?   @map("hangar_id") // Added hangarId
  createdAt     DateTime  @default(now()) @map("created_at") @db.DateTime(6)
  detectedAt    DateTime  @map("detected_at") @db.DateTime(6)
  estimatedCriticalTime DateTime? @map("estimated_critical_time") @db.DateTime(6) // SQL has NOT NULL, TS had optional
  acknowledgedAt DateTime? @map("acknowledged_at") @db.DateTime(6)
  resolvedAt    DateTime? @map("resolved_at") @db.DateTime(6)

  batch         Batch?    @relation(fields: [batchId], references: [id])
  hangar        Hangar?   @relation(fields: [hangarId], references: [id]) // Relation to Hangar
  AlertTeam     AlertTeam[]

  @@map("alerts")
}

// Explicit many-to-many relation table for Alert and Team
model AlertTeam {
  alertId BigInt @map("alert_id")
  teamId  BigInt @map("team_id")
  alert   Alert  @relation(fields: [alertId], references: [id])
  team    Team   @relation(fields: [teamId], references: [id])

  @@id([alertId, teamId])
  @@map("alert_teams")
}


model Intervention {
  id            BigInt      @id @default(autoincrement())
  title         String      // Added from TypeScript types
  description   String      @db.VarChar(1000)
  scheduledTime DateTime    @map("scheduled_time") @db.DateTime(6)
  expectedResolutionTime DateTime? @map("expected_resolution_time") @db.DateTime(6) // SQL has NOT NULL
  actualResolutionTime DateTime? @map("actual_resolution_time") @db.DateTime(6)
  hangarId      BigInt      @map("hangar_id")
  batchId       BigInt?     @map("batch_id") // Added from TypeScript types
  teamId        BigInt      @map("team_id")
  status        InterventionStatus @default(PLANNED) // Added from TypeScript types
  notes         String?     @db.Text // Added from TypeScript types
  createdAt     DateTime    @default(now()) @map("created_at") @db.DateTime(6)

  hangar        Hangar      @relation(fields: [hangarId], references: [id])
  batch         Batch?      @relation(fields: [batchId], references: [id])
  team          Team        @relation(fields: [teamId], references: [id])

  @@map("interventions")
}

model Kpi {
  id            BigInt    @id @default(autoincrement()) @map("id")
  hangarId      BigInt?   @map("hangar_id")
  totalBatches  Int       @map("total_batches")
  riskyBatches  Int       @map("risky_batches")
  interventionsCompleted Int? @map("interventions_completed")
  averageStorageTime Float @map("average_storage_time")
  capacityUtilization Float? @map("capacity_utilization")
  alertsResolvedRatio Float? @map("alerts_resolved_ratio")
  calculatedAt  DateTime  @default(now()) @map("calculated_at") @db.DateTime(6)
  period        KpiPeriod @default(daily)

  hangar        Hangar?   @relation(fields: [hangarId], references: [id])

  @@map("kpi")
}

enum UserRole {
  SUPER_ADMIN
  TEAM_MANAGER
  USER
}

enum BatchStatus {
  STOCKED
  PROCESSING
  TRANSPORTED
  SPOILED
}

enum AlertType {
  STORAGE_EXPIRY
  INTERVENTION_NEEDED
  LOW_STOCK
  EQUIPMENT_FAILURE
}

enum AlertSeverity {
  CRITICAL
  EMERGENCY
  WARNING
  INFO // Added INFO from TS types, SQL only had CRITICAL, EMERGENCY, WARNING
}

enum AlertStatus {
  ACTIVE
  ACKNOWLEDGED
  RESOLVED
}

enum InterventionStatus {
  PLANNED
  IN_PROGRESS
  COMPLETED
  CANCELLED
}

enum KpiPeriod {
  daily
  weekly
  monthly
}
